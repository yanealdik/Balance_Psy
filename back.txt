// ============================================================================
// 1. pom.xml
// ============================================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.balancepsy</groupId>
    <artifactId>balancepsy-backend</artifactId>
    <version>1.0.0</version>
    <name>BalancePsy Backend</name>
    <description>Mental Health Platform Backend</description>
    
    <properties>
        <java.version>17</java.version>
        <jjwt.version>0.12.3</jjwt.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        
        <!-- PostgreSQL Driver -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>

// ============================================================================
// 2. application.yml
// ============================================================================
spring:
  application:
    name: balancepsy-backend
  
  datasource:
    url: jdbc:postgresql://localhost:5432/balancepsy_db
    username: postgres
    password: your_password_here
    driver-class-name: org.postgresql.Driver
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 30000
  
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
        jdbc:
          time_zone: UTC
  
  mail:
    host: smtp.gmail.com
    port: 587
    username: your_email@gmail.com
    password: your_app_password_here
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
          connectiontimeout: 5000
          timeout: 5000
          writetimeout: 5000
    default-encoding: UTF-8

server:
  port: 8080
  servlet:
    context-path: /api

app:
  jwt:
    secret: your-secret-key-min-256-bits-long-change-in-production
    expiration: 86400000 # 24 hours
  email:
    verification:
      expiration: 600000 # 10 minutes
    from: noreply@balancepsy.com
  cors:
    allowed-origins: http://localhost:3000,http://localhost:8081

logging:
  level:
    com.balancepsy: DEBUG
    org.springframework.security: DEBUG

// ============================================================================
// 3. Entity: User
// ============================================================================
package com.balancepsy.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_id")
    private Long userId;
    
    @Column(nullable = false, unique = true)
    private String email;
    
    @Column(name = "password_hash", nullable = false)
    private String passwordHash;
    
    @Column(name = "full_name", nullable = false)
    private String fullName;
    
    private String phone;
    
    @Column(name = "date_of_birth")
    private LocalDate dateOfBirth;
    
    @Column(name = "avatar_url")
    private String avatarUrl;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    @Builder.Default
    private UserRole role = UserRole.CLIENT;
    
    @Column(name = "is_active", nullable = false)
    @Builder.Default
    private Boolean isActive = true;
    
    @Column(name = "email_verified", nullable = false)
    @Builder.Default
    private Boolean emailVerified = false;
    
    @Column(name = "parent_email")
    private String parentEmail;
    
    @Column(name = "parent_email_verified")
    @Builder.Default
    private Boolean parentEmailVerified = false;
    
    private String gender;
    
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "user_interests", joinColumns = @JoinColumn(name = "user_id"))
    @Column(name = "interest_name")
    @Builder.Default
    private Set<String> interests = new HashSet<>();
    
    @Column(name = "registration_goal")
    private String registrationGoal;
    
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;
    
    @Column(name = "last_login")
    private LocalDateTime lastLogin;
    
    public enum UserRole {
        CLIENT, PSYCHOLOGIST, ADMIN
    }
}

// ============================================================================
// 4. Entity: EmailVerification
// ============================================================================
package com.balancepsy.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(name = "email_verifications")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmailVerification {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String email;
    
    @Column(nullable = false, length = 6)
    private String code;
    
    @Column(name = "is_parent_email", nullable = false)
    @Builder.Default
    private Boolean isParentEmail = false;
    
    @Column(name = "is_verified", nullable = false)
    @Builder.Default
    private Boolean isVerified = false;
    
    @Column(name = "expires_at", nullable = false)
    private LocalDateTime expiresAt;
    
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "verified_at")
    private LocalDateTime verifiedAt;
    
    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expiresAt);
    }
}

// ============================================================================
// 5. Repository: UserRepository
// ============================================================================
package com.balancepsy.repository;

import com.balancepsy.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    boolean existsByEmail(String email);
}

// ============================================================================
// 6. Repository: EmailVerificationRepository
// ============================================================================
package com.balancepsy.repository;

import com.balancepsy.entity.EmailVerification;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface EmailVerificationRepository extends JpaRepository<EmailVerification, Long> {
    Optional<EmailVerification> findTopByEmailAndIsVerifiedFalseOrderByCreatedAtDesc(String email);
    Optional<EmailVerification> findByEmailAndCodeAndIsVerifiedFalse(String email, String code);
    List<EmailVerification> findByExpiresAtBeforeAndIsVerifiedFalse(LocalDateTime dateTime);
}

// ============================================================================
// 7. DTO: Request DTOs
// ============================================================================
package com.balancepsy.dto.request;

import jakarta.validation.constraints.*;
import lombok.*;

import java.time.LocalDate;
import java.util.Set;

// Send Email Code Request
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SendEmailCodeRequest {
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;
    
    private Boolean isParentEmail = false;
}

// Verify Email Code Request
@Data
@NoArgsConstructor
@AllArgsConstructor
public class VerifyEmailCodeRequest {
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;
    
    @NotBlank(message = "Code is required")
    @Size(min = 6, max = 6, message = "Code must be 6 digits")
    private String code;
    
    private Boolean isParentEmail = false;
}

// Registration Request (all steps combined)
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RegistrationRequest {
    
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;
    
    @NotBlank(message = "Password is required")
    @Size(min = 6, message = "Password must be at least 6 characters")
    private String password;
    
    @NotBlank(message = "Password confirmation is required")
    private String passwordRepeat;
    
    @NotBlank(message = "Full name is required")
    @Size(min = 2, max = 255, message = "Name must be between 2 and 255 characters")
    private String fullName;
    
    @NotNull(message = "Date of birth is required")
    @Past(message = "Date of birth must be in the past")
    private LocalDate dateOfBirth;
    
    private String gender; // Optional
    
    @NotEmpty(message = "At least one interest is required")
    private Set<String> interests;
    
    private String registrationGoal; // Optional
    
    private String parentEmail; // Required if < 18
}

// Login Request
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;
    
    @NotBlank(message = "Password is required")
    private String password;
}

// ============================================================================
// 8. DTO: Response DTOs
// ============================================================================
package com.balancepsy.dto.response;

import lombok.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Set;

// Generic API Response
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ApiResponse {
    private Boolean success;
    private String message;
    private Object data;
}

// Email Verification Response
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmailVerificationResponse {
    private Boolean success;
    private String message;
    private String email;
    private LocalDateTime expiresAt;
}

// User Response
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponse {
    private Long userId;
    private String email;
    private String fullName;
    private LocalDate dateOfBirth;
    private String gender;
    private Set<String> interests;
    private String role;
    private Boolean emailVerified;
    private LocalDateTime createdAt;
}

// Login Response
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LoginResponse {
    private String token;
    private String type = "Bearer";
    private UserResponse user;
}

// ============================================================================
// 9. Service: EmailService
// ============================================================================
package com.balancepsy.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class EmailService {
    
    private final JavaMailSender mailSender;
    
    @Value("${app.email.from}")
    private String fromEmail;
    
    public void sendVerificationCode(String to, String code, boolean isParentEmail) {
        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(fromEmail);
            message.setTo(to);
            
            if (isParentEmail) {
                message.setSubject("BalancePsy - Parental Consent Verification");
                message.setText(String.format(
                    "Hello,\n\n" +
                    "Your child is trying to register on BalancePsy platform.\n\n" +
                    "Verification code: %s\n\n" +
                    "This code will expire in 10 minutes.\n\n" +
                    "If you did not authorize this registration, please ignore this email.\n\n" +
                    "Best regards,\n" +
                    "BalancePsy Team",
                    code
                ));
            } else {
                message.setSubject("BalancePsy - Email Verification");
                message.setText(String.format(
                    "Hello,\n\n" +
                    "Thank you for registering with BalancePsy!\n\n" +
                    "Your verification code: %s\n\n" +
                    "This code will expire in 10 minutes.\n\n" +
                    "Best regards,\n" +
                    "BalancePsy Team",
                    code
                ));
            }
            
            mailSender.send(message);
            log.info("Verification email sent to: {}", to);
            
        } catch (Exception e) {
            log.error("Failed to send email to: {}", to, e);
            throw new RuntimeException("Failed to send verification email");
        }
    }
}

// ============================================================================
// 10. Service: EmailVerificationService
// ============================================================================
package com.balancepsy.service;

import com.balancepsy.entity.EmailVerification;
import com.balancepsy.repository.EmailVerificationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.Random;

@Service
@RequiredArgsConstructor
@Slf4j
public class EmailVerificationService {
    
    private final EmailVerificationRepository verificationRepository;
    private final EmailService emailService;
    
    @Value("${app.email.verification.expiration}")
    private Long expirationMs;
    
    @Transactional
    public EmailVerification createVerificationCode(String email, boolean isParentEmail) {
        String code = generateSixDigitCode();
        LocalDateTime expiresAt = LocalDateTime.now().plusSeconds(expirationMs / 1000);
        
        EmailVerification verification = EmailVerification.builder()
                .email(email)
                .code(code)
                .isParentEmail(isParentEmail)
                .expiresAt(expiresAt)
                .build();
        
        verification = verificationRepository.save(verification);
        
        // Send email
        emailService.sendVerificationCode(email, code, isParentEmail);
        
        log.info("Verification code created for email: {}, isParent: {}", email, isParentEmail);
        return verification;
    }
    
    @Transactional
    public boolean verifyCode(String email, String code, boolean isParentEmail) {
        EmailVerification verification = verificationRepository
                .findByEmailAndCodeAndIsVerifiedFalse(email, code)
                .orElse(null);
        
        if (verification == null) {
            log.warn("Verification not found for email: {}", email);
            return false;
        }
        
        if (verification.getIsParentEmail() != isParentEmail) {
            log.warn("Parent email flag mismatch for: {}", email);
            return false;
        }
        
        if (verification.isExpired()) {
            log.warn("Verification code expired for: {}", email);
            return false;
        }
        
        verification.setIsVerified(true);
        verification.setVerifiedAt(LocalDateTime.now());
        verificationRepository.save(verification);
        
        log.info("Email verified successfully: {}", email);
        return true;
    }
    
    public boolean isEmailVerified(String email, boolean isParentEmail) {
        EmailVerification verification = verificationRepository
                .findTopByEmailAndIsVerifiedFalseOrderByCreatedAtDesc(email)
                .orElse(null);
        
        return verification != null 
                && verification.getIsVerified() 
                && verification.getIsParentEmail() == isParentEmail;
    }
    
    private String generateSixDigitCode() {
        Random random = new Random();
        int code = 100000 + random.nextInt(900000);
        return String.valueOf(code);
    }
    
    @Transactional
    public void cleanupExpiredCodes() {
        LocalDateTime now = LocalDateTime.now();
        verificationRepository.deleteAll(
            verificationRepository.findByExpiresAtBeforeAndIsVerifiedFalse(now)
        );
    }
}

// ============================================================================
// 11. Service: AuthService
// ============================================================================
package com.balancepsy.service;

import com.balancepsy.dto.request.LoginRequest;
import com.balancepsy.dto.request.RegistrationRequest;
import com.balancepsy.dto.response.LoginResponse;
import com.balancepsy.dto.response.UserResponse;
import com.balancepsy.entity.User;
import com.balancepsy.exception.BadRequestException;
import com.balancepsy.exception.ResourceNotFoundException;
import com.balancepsy.repository.UserRepository;
import com.balancepsy.security.JwtTokenProvider;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Period;

@Service
@RequiredArgsConstructor
@Slf4j
public class AuthService {
    
    private final UserRepository userRepository;
    private final EmailVerificationService verificationService;
    private final PasswordEncoder passwordEncoder;
    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider tokenProvider;
    
    @Transactional
    public UserResponse registerUser(RegistrationRequest request) {
        // Validate passwords match
        if (!request.getPassword().equals(request.getPasswordRepeat())) {
            throw new BadRequestException("Passwords do not match");
        }
        
        // Check if email already exists
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new BadRequestException("Email already registered");
        }
        
        // Verify email is confirmed
        if (!verificationService.isEmailVerified(request.getEmail(), false)) {
            throw new BadRequestException("Email not verified");
        }
        
        // Calculate age
        int age = Period.between(request.getDateOfBirth(), LocalDate.now()).getYears();
        
        // If under 18, check parent email
        if (age < 18) {
            if (request.getParentEmail() == null || request.getParentEmail().isBlank()) {
                throw new BadRequestException("Parent email required for users under 18");
            }
            
            if (!verificationService.isEmailVerified(request.getParentEmail(), true)) {
                throw new BadRequestException("Parent email not verified");
            }
        }
        
        // Create user
        User user = User.builder()
                .email(request.getEmail())
                .passwordHash(passwordEncoder.encode(request.getPassword()))
                .fullName(request.getFullName())
                .dateOfBirth(request.getDateOfBirth())
                .gender(request.getGender())
                .interests(request.getInterests())
                .registrationGoal(request.getRegistrationGoal())
                .parentEmail(request.getParentEmail())
                .emailVerified(true)
                .parentEmailVerified(age < 18)
                .role(User.UserRole.CLIENT)
                .isActive(true)
                .build();
        
        user = userRepository.save(user);
        log.info("User registered successfully: {}", user.getEmail());
        
        return mapToUserResponse(user);
    }
    
    @Transactional
    public LoginResponse login(LoginRequest request) {
        User user = userRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> new BadRequestException("Invalid email or password"));
        
        if (!user.getEmailVerified()) {
            throw new BadRequestException("Email not verified");
        }
        
        if (!user.getIsActive()) {
            throw new BadRequestException("Account is deactivated");
        }
        
        // Authenticate
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword())
        );
        
        // Generate JWT token
        String token = tokenProvider.generateToken(authentication);
        
        // Update last login
        user.setLastLogin(LocalDateTime.now());
        userRepository.save(user);
        
        log.info("User logged in: {}", user.getEmail());
        
        return LoginResponse.builder()
                .token(token)
                .type("Bearer")
                .user(mapToUserResponse(user))
                .build();
    }
    
    private UserResponse mapToUserResponse(User user) {
        return UserResponse.builder()
                .userId(user.getUserId())
                .email(user.getEmail())
                .fullName(user.getFullName())
                .dateOfBirth(user.getDateOfBirth())
                .gender(user.getGender())
                .interests(user.getInterests())
                .role(user.getRole().name())
                .emailVerified(user.getEmailVerified())
                .createdAt(user.getCreatedAt())
                .build();
    }
}

// ============================================================================
// 12. Controller: AuthController
// ============================================================================
package com.balancepsy.controller;

import com.balancepsy.dto.request.*;
import com.balancepsy.dto.response.*;
import com.balancepsy.entity.EmailVerification;
import com.balancepsy.service.AuthService;
import com.balancepsy.service.EmailVerificationService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
@Slf4j
@CrossOrigin(origins = "*")
public class AuthController {
    
    private final EmailVerificationService verificationService;
    private final AuthService authService;
    
    @PostMapping("/send-code")
    public ResponseEntity<ApiResponse> sendVerificationCode(
            @Valid @RequestBody SendEmailCodeRequest request) {
        
        EmailVerification verification = verificationService.createVerificationCode(
                request.getEmail(),
                request.getIsParentEmail()
        );
        
        EmailVerificationResponse response = EmailVerificationResponse.builder()
                .success(true)
                .message("Verification code sent to email")
                .email(verification.getEmail())
                .expiresAt(verification.getExpiresAt())
                .build();
        
        return ResponseEntity.ok(ApiResponse.builder()
                .success(true)
                .message("Code sent successfully")
                .data(response)
                .build());
    }
    
    @PostMapping("/verify-code")
    public ResponseEntity<ApiResponse> verifyCode(
            @Valid @RequestBody VerifyEmailCodeRequest request) {
        
        boolean verified = verificationService.verifyCode(
                request.getEmail(),
                request.getCode(),
                request.getIsParentEmail()
        );
        
        if (!verified) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                    .body(ApiResponse.builder()
                            .success(false)
                            .message("Invalid or expired verification code")
                            .build());
        }
        
        return ResponseEntity.ok(ApiResponse.builder()
                .success(true)
                .message("Email verified successfully")
                .build());
    }
    
    @PostMapping("/register")
    public ResponseEntity<ApiResponse> register(
            @Valid @RequestBody RegistrationRequest request) {
        
        UserResponse user = authService.registerUser(request);
        
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.builder()
                        .success(true)
                        .message("Registration successful")
                        .data(user)
                        .build());
    }
    
    @PostMapping("/login")
    public ResponseEntity<ApiResponse> login(
            @Valid @RequestBody LoginRequest request) {
        
        LoginResponse loginResponse = authService.login(request);
        
        return ResponseEntity.ok(ApiResponse.builder()
                .success(true)
                .message("Login successful")
                .data(loginResponse)
                .build());
    }
}

// ============================================================================
// 13. Security: JwtTokenProvider
// ============================================================================
package com.balancepsy.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;

@Component
@Slf4j
public class JwtTokenProvider {
    
    @Value("${app.jwt.secret}")
    private String jwtSecret;
    
    @Value("${app.jwt.expiration}")
    private Long jwtExpiration;
    
    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
    }
    
    public String generateToken(Authentication authentication) {
        String email = authentication.getName();
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpiration);
        
        return Jwts.builder()
                .subject(email)
                .issuedAt(now)
                .expiration(expiryDate)
                .signWith(getSigningKey())
                .compact();
    }
    
    public String getEmailFromToken(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
        
        return claims.getSubject();
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parser()
                    .verifyWith(getSigningKey())
                    .build()
                    .parseSignedClaims(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            log.error("Invalid JWT token: {}", e.getMessage());
        }
        return false;
    }
}

// ============================================================================
// 14. Security: JwtAuthenticationFilter
// ============================================================================
package com.balancepsy.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    private final JwtTokenProvider tokenProvider;
    private final CustomUserDetailsService userDetailsService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);
            
            if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {
                String email = tokenProvider.getEmailFromToken(jwt);
                UserDetails userDetails = userDetailsService.loadUserByUsername(email);
                
                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities());
                
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            log.error("Could not set user authentication in security context", e);
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}

// ============================================================================
// 15. Security: CustomUserDetailsService
// ============================================================================
package com.balancepsy.security;

import com.balancepsy.entity.User;
import com.balancepsy.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;

@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {
    
    private final UserRepository userRepository;
    
    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + email));
        
        List<SimpleGrantedAuthority> authorities = Collections.singletonList(
                new SimpleGrantedAuthority("ROLE_" + user.getRole().name())
        );
        
        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getEmail())
                .password(user.getPasswordHash())
                .authorities(authorities)
                .accountExpired(false)
                .accountLocked(!user.getIsActive())
                .credentialsExpired(false)
                .disabled(!user.getIsActive())
                .build();
    }
}

// ============================================================================
// 16. Security: SecurityConfig
// ============================================================================
package com.balancepsy.config;

import com.balancepsy.security.CustomUserDetailsService;
import com.balancepsy.security.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {
    
    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable)
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            .sessionManagement(session -> 
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/auth/**").permitAll()
                .requestMatchers("/error").permitAll()
                .anyRequest().authenticated()
            )
            .authenticationProvider(authenticationProvider())
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOriginPatterns(List.of("*"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setExposedHeaders(Arrays.asList("Authorization"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}

// ============================================================================
// 17. Exception Handling: Custom Exceptions
// ============================================================================
package com.balancepsy.exception;

public class BadRequestException extends RuntimeException {
    public BadRequestException(String message) {
        super(message);
    }
}

package com.balancepsy.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

// ============================================================================
// 18. Exception Handling: GlobalExceptionHandler
// ============================================================================
package com.balancepsy.exception;

import com.balancepsy.dto.response.ApiResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ApiResponse> handleBadRequest(BadRequestException ex) {
        log.error("Bad request: {}", ex.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(ApiResponse.builder()
                        .success(false)
                        .message(ex.getMessage())
                        .build());
    }
    
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiResponse> handleResourceNotFound(ResourceNotFoundException ex) {
        log.error("Resource not found: {}", ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(ApiResponse.builder()
                        .success(false)
                        .message(ex.getMessage())
                        .build());
    }
    
    @ExceptionHandler(BadCredentialsException.class)
    public ResponseEntity<ApiResponse> handleBadCredentials(BadCredentialsException ex) {
        log.error("Bad credentials: {}", ex.getMessage());
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                .body(ApiResponse.builder()
                        .success(false)
                        .message("Invalid email or password")
                        .build());
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        
        log.error("Validation errors: {}", errors);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(ApiResponse.builder()
                        .success(false)
                        .message("Validation failed")
                        .data(errors)
                        .build());
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse> handleGlobalException(Exception ex) {
        log.error("Unexpected error occurred", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.builder()
                        .success(false)
                        .message("An unexpected error occurred")
                        .build());
    }
}

// ============================================================================
// 19. Main Application Class
// ============================================================================
package com.balancepsy;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
public class BalancePsyApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(BalancePsyApplication.class, args);
    }
}

// ============================================================================
// 20. Scheduled Tasks: CleanupScheduler
// ============================================================================
package com.balancepsy.scheduler;

import com.balancepsy.service.EmailVerificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class CleanupScheduler {
    
    private final EmailVerificationService verificationService;
    
    @Scheduled(fixedRate = 3600000) // Every hour
    public void cleanupExpiredVerifications() {
        log.info("Starting cleanup of expired verification codes");
        verificationService.cleanupExpiredCodes();
        log.info("Cleanup completed");
    }
}

// ============================================================================
// 21. Additional: UserController (for testing)
// ============================================================================
package com.balancepsy.controller;

import com.balancepsy.dto.response.ApiResponse;
import com.balancepsy.dto.response.UserResponse;
import com.balancepsy.entity.User;
import com.balancepsy.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
@CrossOrigin(origins = "*")
public class UserController {
    
    private final UserRepository userRepository;
    
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ApiResponse> getCurrentUser(Authentication authentication) {
        String email = authentication.getName();
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("User not found"));
        
        UserResponse userResponse = UserResponse.builder()
                .userId(user.getUserId())
                .email(user.getEmail())
                .fullName(user.getFullName())
                .dateOfBirth(user.getDateOfBirth())
                .gender(user.getGender())
                .interests(user.getInterests())
                .role(user.getRole().name())
                .emailVerified(user.getEmailVerified())
                .createdAt(user.getCreatedAt())
                .build();
        
        return ResponseEntity.ok(ApiResponse.builder()
                .success(true)
                .message("User retrieved successfully")
                .data(userResponse)
                .build());
    }
}

// ============================================================================
// 22. README.md - –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –ø—Ä–æ–µ–∫—Ç–∞
// ============================================================================
/*
# BalancePsy Backend API

## üöÄ –û–ø–∏—Å–∞–Ω–∏–µ
Backend –¥–ª—è –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –º–µ–Ω—Ç–∞–ª—å–Ω–æ–≥–æ –∑–¥–æ—Ä–æ–≤—å—è BalancePsy —Å –ø–æ—à–∞–≥–æ–≤–æ–π —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–µ–π,
–≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–µ–π email –∏ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–º –∫–æ–Ω—Ç—Ä–æ–ª–µ–º –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –º–ª–∞–¥—à–µ 18 –ª–µ—Ç.

## üìã –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏
- Java 17
- Spring Boot 3.2.0
- Spring Security + JWT
- PostgreSQL
- JavaMailSender (SMTP)
- Maven

## ‚öôÔ∏è –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏ –∑–∞–ø—É—Å–∫

### 1. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å PostgreSQL
–°–æ–∑–¥–∞–π—Ç–µ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö:
```sql
CREATE DATABASE balancepsy_db;
```

### 2. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å application.yml
–£–∫–∞–∂–∏—Ç–µ —Å–≤–æ–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:
```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/balancepsy_db
    username: postgres
    password: your_password
  
  mail:
    username: your_email@gmail.com
    password: your_app_password

app:
  jwt:
    secret: your-secret-key-min-256-bits-long
```

### 3. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å Gmail App Password
1. –í–∫–ª—é—á–∏—Ç–µ 2FA –≤ Google –∞–∫–∫–∞—É–Ω—Ç–µ
2. –°–æ–∑–¥–∞–π—Ç–µ App Password: https://myaccount.google.com/apppasswords
3. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –µ–≥–æ –≤ application.yml

### 4. –°–æ–±—Ä–∞—Ç—å –∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å
```bash
mvn clean install
mvn spring-boot:run
```

API –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ –Ω–∞: http://localhost:8080/api

## üìö API Endpoints

### üîê –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è

#### 1. –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–¥ –Ω–∞ email
```http
POST /api/auth/send-code
Content-Type: application/json

{
  "email": "user@example.com",
  "isParentEmail": false
}
```

**–û—Ç–≤–µ—Ç:**
```json
{
  "success": true,
  "message": "Code sent successfully",
  "data": {
    "success": true,
    "message": "Verification code sent to email",
    "email": "user@example.com",
    "expiresAt": "2025-10-29T10:45:00"
  }
}
```

#### 2. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å email –∫–æ–¥
```http
POST /api/auth/verify-code
Content-Type: application/json

{
  "email": "user@example.com",
  "code": "123456",
  "isParentEmail": false
}
```

**–û—Ç–≤–µ—Ç:**
```json
{
  "success": true,
  "message": "Email verified successfully"
}
```

#### 3. –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
```http
POST /api/auth/register
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "password123",
  "passwordRepeat": "password123",
  "fullName": "–ò–≤–∞–Ω –ò–≤–∞–Ω–æ–≤",
  "dateOfBirth": "2005-05-15",
  "gender": "male",
  "interests": ["–ü—Å–∏—Ö–æ–ª–æ–≥–∏—è", "–ú–µ–¥–∏—Ç–∞—Ü–∏—è", "–ô–æ–≥–∞"],
  "registrationGoal": "–ù–∞–π—Ç–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –±–∞–ª–∞–Ω—Å",
  "parentEmail": "parent@example.com"
}
```

**–û—Ç–≤–µ—Ç:**
```json
{
  "success": true,
  "message": "Registration successful",
  "data": {
    "userId": 1,
    "email": "user@example.com",
    "fullName": "–ò–≤–∞–Ω –ò–≤–∞–Ω–æ–≤",
    "dateOfBirth": "2005-05-15",
    "gender": "male",
    "interests": ["–ü—Å–∏—Ö–æ–ª–æ–≥–∏—è", "–ú–µ–¥–∏—Ç–∞—Ü–∏—è"],
    "role": "CLIENT",
    "emailVerified": true,
    "createdAt": "2025-10-29T10:30:00"
  }
}
```

#### 4. –í—Ö–æ–¥ (Login)
```http
POST /api/auth/login
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "password123"
}
```

**–û—Ç–≤–µ—Ç:**
```json
{
  "success": true,
  "message": "Login successful",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "type": "Bearer",
    "user": {
      "userId": 1,
      "email": "user@example.com",
      "fullName": "–ò–≤–∞–Ω –ò–≤–∞–Ω–æ–≤",
      "role": "CLIENT",
      "emailVerified": true
    }
  }
}
```

### üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏

#### –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
```http
GET /api/users/me
Authorization: Bearer {token}
```

**–û—Ç–≤–µ—Ç:**
```json
{
  "success": true,
  "message": "User retrieved successfully",
  "data": {
    "userId": 1,
    "email": "user@example.com",
    "fullName": "–ò–≤–∞–Ω –ò–≤–∞–Ω–æ–≤",
    "dateOfBirth": "2005-05-15",
    "gender": "male",
    "interests": ["–ü—Å–∏—Ö–æ–ª–æ–≥–∏—è", "–ú–µ–¥–∏—Ç–∞—Ü–∏—è"],
    "role": "CLIENT",
    "emailVerified": true,
    "createdAt": "2025-10-29T10:30:00"
  }
}
```

## üîí –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å

### JWT Token
- –°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è: 24 —á–∞—Å–∞
- –ü–µ—Ä–µ–¥–∞–µ—Ç—Å—è –≤ –∑–∞–≥–æ–ª–æ–≤–∫–µ: `Authorization: Bearer {token}`
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –≤—Å–µ—Ö –∑–∞—â–∏—â–µ–Ω–Ω—ã—Ö endpoints

### –•—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª–µ–π
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è BCrypt —Å —Å–∏–ª–æ–π 10
- –ü–∞—Ä–æ–ª–∏ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –æ—Ç–∫—Ä—ã—Ç–æ–º –≤–∏–¥–µ

### –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è Email
- 6-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥
- –°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è: 10 –º–∏–Ω—É—Ç
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –∏—Å—Ç–µ–∫—à–∏—Ö –∫–æ–¥–æ–≤ –∫–∞–∂–¥—ã–π —á–∞—Å

### –†–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π –∫–æ–Ω—Ç—Ä–æ–ª—å
- –î–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π < 18 –ª–µ—Ç —Ç—Ä–µ–±—É–µ—Ç—Å—è `parentEmail`
- –†–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π email —Ç–∞–∫–∂–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—é
- –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –æ–±–æ–∏—Ö –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–π

## üìä –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

```
src/main/java/com/balancepsy/
‚îú‚îÄ‚îÄ config/              # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ (Security, CORS)
‚îú‚îÄ‚îÄ controller/          # REST –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—ã
‚îú‚îÄ‚îÄ dto/                 # Data Transfer Objects
‚îÇ   ‚îú‚îÄ‚îÄ request/        # Request DTOs
‚îÇ   ‚îî‚îÄ‚îÄ response/       # Response DTOs
‚îú‚îÄ‚îÄ entity/             # JPA —Å—É—â–Ω–æ—Å—Ç–∏
‚îú‚îÄ‚îÄ exception/          # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏–π
‚îú‚îÄ‚îÄ repository/         # JPA —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
‚îú‚îÄ‚îÄ scheduler/          # Scheduled –∑–∞–¥–∞—á–∏
‚îú‚îÄ‚îÄ security/           # JWT, —Ñ–∏–ª—å—Ç—Ä—ã, UserDetails
‚îî‚îÄ‚îÄ service/            # –ë–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞
```

## üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ API

### –° –ø–æ–º–æ—â—å—é cURL:

**1. –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–¥:**
```bash
curl -X POST http://localhost:8080/api/auth/send-code \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","isParentEmail":false}'
```

**2. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∫–æ–¥:**
```bash
curl -X POST http://localhost:8080/api/auth/verify-code \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","code":"123456","isParentEmail":false}'
```

**3. –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è:**
```bash
curl -X POST http://localhost:8080/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "email":"test@example.com",
    "password":"password123",
    "passwordRepeat":"password123",
    "fullName":"Test User",
    "dateOfBirth":"2000-01-01",
    "interests":["–ü—Å–∏—Ö–æ–ª–æ–≥–∏—è"]
  }'
```

**4. –í–æ–π—Ç–∏:**
```bash
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"password123"}'
```

**5. –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å:**
```bash
curl -X GET http://localhost:8080/api/users/me \
  -H "Authorization: Bearer YOUR_TOKEN_HERE"
```

## üîÑ –ü–æ—Ç–æ–∫ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏

1. **–®–∞–≥ 1**: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤–æ–¥–∏—Ç email ‚Üí `/auth/send-code`
2. **–®–∞–≥ 2**: –°–∏—Å—Ç–µ–º–∞ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç 6-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥ –Ω–∞ email
3. **–®–∞–≥ 3**: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤–æ–¥–∏—Ç –∫–æ–¥ ‚Üí `/auth/verify-code`
4. **–®–∞–≥ 4**: Email –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω
5. **–®–∞–≥ 5**: –ï—Å–ª–∏ –≤–æ–∑—Ä–∞—Å—Ç < 18:
   - –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–¥ –Ω–∞ `parentEmail` ‚Üí `/auth/send-code` (isParentEmail=true)
   - –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π email ‚Üí `/auth/verify-code` (isParentEmail=true)
6. **–®–∞–≥ 6**: –ó–∞–ø–æ–ª–Ω–∏—Ç—å –≤—Å–µ –ø–æ–ª—è –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å ‚Üí `/auth/register`
7. **–®–∞–≥ 7**: –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!

## ‚ö†Ô∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫

–í—Å–µ –æ—à–∏–±–∫–∏ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è –≤ –µ–¥–∏–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ:
```json
{
  "success": false,
  "message": "Error description",
  "data": null
}
```

**–ö–æ–¥—ã –æ—à–∏–±–æ–∫:**
- `400` - Bad Request (–Ω–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ)
- `401` - Unauthorized (–Ω–µ–≤–µ—Ä–Ω—ã–µ credentials)
- `404` - Not Found (—Ä–µ—Å—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω)
- `500` - Internal Server Error

## üåê CORS
–ù–∞—Å—Ç—Ä–æ–µ–Ω –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Flutter –∏ web:
- –†–∞–∑—Ä–µ—à–µ–Ω—ã –≤—Å–µ origins –≤ dev —Ä–µ–∂–∏–º–µ
- –î–ª—è production —É–∫–∞–∂–∏—Ç–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –¥–æ–º–µ–Ω—ã

## üìù –í–∞–ª–∏–¥–∞—Ü–∏—è

### Email
- –§–æ—Ä–º–∞—Ç: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π email
- –£–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å: –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏

### –ü–∞—Ä–æ–ª—å
- –ú–∏–Ω–∏–º—É–º 6 —Å–∏–º–≤–æ–ª–æ–≤
- –î–æ–ª–∂–µ–Ω —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º

### –ò–º—è
- –ú–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞
- –ú–∞–∫—Å–∏–º—É–º 255 —Å–∏–º–≤–æ–ª–æ–≤

### –î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è
- –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –≤–æ–∑—Ä–∞—Å—Ç: 13 –ª–µ—Ç
- –§–æ—Ä–º–∞—Ç: YYYY-MM-DD

### –ò–Ω—Ç–µ—Ä–µ—Å—ã
- –ú–∏–Ω–∏–º—É–º 1 –∏–Ω—Ç–µ—Ä–µ—Å
- –°–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –∫–∞–∫ Set<String>

## üöÄ –†–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ

### Production –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:
1. –°–º–µ–Ω–∏—Ç–µ JWT secret –Ω–∞ –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–∏–π
2. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ production SMTP —Å–µ—Ä–≤–µ—Ä
3. –ù–∞—Å—Ç—Ä–æ–π—Ç–µ CORS –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –¥–æ–º–µ–Ω–æ–≤
4. –í–∫–ª—é—á–∏—Ç–µ HTTPS
5. –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ

## üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞
–î–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤ –∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π: support@balancepsy.com

## üìÑ –õ–∏—Ü–µ–Ω–∑–∏—è
Proprietary - BalancePsy Platform
*/